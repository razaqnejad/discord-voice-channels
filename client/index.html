<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebRTC Voice Chat</title>
    <script src="https://cdn.socket.io/4.0.1/socket.io.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/simple-peer/9.11.1/simplepeer.min.js"></script>
</head>
<body>
    <h1>Voice Chat</h1>
    <input type="text" id="channelId" placeholder="Enter channel ID">
    <button onclick="joinChannel()">Join Channel</button>
    <button onclick="leaveChannel()">Leave Channel</button>
    <button onclick="toggleMute()">Mute/Unmute</button>
    <h2>Users in Channel:</h2>
    <ul id="userList"></ul>

    <script>
        const socket = io("https://discord-voice-channels.onrender.com", {
            transports: ["websocket"],
            upgrade: false
        });

        let peers = {}; // Ø°Ø®ÛŒØ±Ù‡ PeerÙ‡Ø§ÛŒ Ù…ØªØµÙ„
        let isMuted = false;
        let currentChannel = null;
        let stream = null; // Ø°Ø®ÛŒØ±Ù‡ Ø¬Ø±ÛŒØ§Ù† ØµÙˆØªÛŒ

        // Ø¯Ø±ÛŒØ§ÙØª ØµØ¯Ø§ Ø§Ø² Ù…ÛŒÚ©Ø±ÙˆÙÙˆÙ†
        async function getMicrophoneStream() {
            try {
                stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                console.log("Microphone access granted.");

                const audio = document.createElement("audio");
                audio.srcObject = stream;
                audio.autoplay = true;
                document.body.appendChild(audio);

                // Ù¾Ø±Ø¯Ø§Ø²Ø´ ØµØ¯Ø§ Ø¨Ø±Ø§ÛŒ ØªØ´Ø®ÛŒØµ ØµØ­Ø¨Øª Ú©Ø±Ø¯Ù†
                const audioContext = new AudioContext();
                const analyser = audioContext.createAnalyser();
                analyser.fftSize = 512;
                const microphone = audioContext.createMediaStreamSource(stream);
                microphone.connect(analyser);

                setInterval(() => {
                    const dataArray = new Uint8Array(analyser.frequencyBinCount);
                    analyser.getByteFrequencyData(dataArray);
                    const volume = dataArray.reduce((a, b) => a + b) / dataArray.length;

                    console.log(`Volume Level: ${volume}`); // Ù†Ù…Ø§ÛŒØ´ Ù…Ù‚Ø¯Ø§Ø± volume Ø¯Ø± Ú©Ù†Ø³ÙˆÙ„
                    const isSpeaking = volume > 10; // Ù…Ù‚Ø¯Ø§Ø± Ù…Ù…Ú©Ù† Ø§Ø³Øª Ø®ÛŒÙ„ÛŒ Ù¾Ø§ÛŒÛŒÙ† Ø¨Ø§Ø´Ø¯ØŒ Ù…ÛŒâ€ŒØªÙˆØ§Ù† Ø§ÙØ²Ø§ÛŒØ´ Ø¯Ø§Ø¯
                    socket.emit("user-speaking", { userId: socket.id, isSpeaking });
                }, 300);

                return stream;
            } catch (error) {
                console.error("Microphone access denied:", error);
                alert("Please allow microphone access to use voice chat.");
                return null;
            }
        }


        async function joinChannel() {
            currentChannel = document.getElementById("channelId").value;
            if (!currentChannel) {
                alert("Please enter a channel ID.");
                return;
            }

            stream = await getMicrophoneStream();
            if (!stream) return;

            socket.emit("join-channel", currentChannel);
        }

        function leaveChannel() {
            if (currentChannel) {
                socket.emit("leave-channel");
                Object.values(peers).forEach(peer => peer.destroy());
                peers = {};
                currentChannel = null;
            }
        }

        function createPeer(userId, initiator) {
            if (peers[userId]) return peers[userId]; // Ø¬Ù„ÙˆÚ¯ÛŒØ±ÛŒ Ø§Ø² Ø§ÛŒØ¬Ø§Ø¯ Ú†Ù†Ø¯Ø¨Ø§Ø±Ù‡â€ŒÛŒ peer

            console.log(`Creating WebRTC Peer: ${userId}`);

            const peer = new SimplePeer({
                initiator,
                trickle: true, // Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² true Ø¨Ø±Ø§ÛŒ Ø¬Ù„ÙˆÚ¯ÛŒØ±ÛŒ Ø§Ø² race conditions
                stream
            });

            peer.on("signal", signal => {
                console.log(`Sending WebRTC signal to ${userId}`);
                socket.emit("webrtc-signal", { signal, to: userId });
            });

            peer.on("stream", userStream => {
                console.log(`Receiving audio stream from ${userId}`);
                const audio = document.createElement("audio");
                audio.srcObject = userStream;
                audio.autoplay = true;
                document.body.appendChild(audio);
            });

            peer.on("close", () => {
                console.log(`Peer connection closed: ${userId}`);
                delete peers[userId];
            });

            // Ù…Ø¯ÛŒØ±ÛŒØª Ù…Ø°Ø§Ú©Ø±Ù‡ Ø®ÙˆØ¯Ú©Ø§Ø±
            peer.on("negotiationneeded", () => {
                console.log(`Negotiation needed for ${userId}`);
                peer.createOffer().then(offer => {
                    return peer.setLocalDescription(offer);
                }).then(() => {
                    socket.emit("webrtc-signal", { signal: peer.localDescription, to: userId });
                }).catch(err => console.error("âš ï¸ Negotiation error:", err));
            });

            peers[userId] = peer;
            return peer;
        }

        socket.on("update-users", (data) => {
            console.log("Updating user list:", data.users);
            const userList = document.getElementById("userList");
            userList.innerHTML = ""; // Ù¾Ø§Ú© Ú©Ø±Ø¯Ù† Ù„ÛŒØ³Øª ÙØ¹Ù„ÛŒ

            data.users.forEach(user => {
                if (!peers[user] && user !== socket.id) { // Ø§ÛŒØ¬Ø§Ø¯ Peer Ø¬Ø¯ÛŒØ¯ Ø¯Ø± ØµÙˆØ±Øª Ù†ÛŒØ§Ø²
                    createPeer(user, true);
                }

                const li = document.createElement("li");
                li.textContent = user;
                li.id = `user-${user}`;
                userList.appendChild(li);
            });

            // ** Ø­Ø°Ù Ù†Ø§Ù… Ú©Ø§Ø±Ø¨Ø±Ø§Ù† ØªØ±Ú© Ú©Ø±Ø¯Ù‡ Ø§Ø² Ù„ÛŒØ³Øª **
            Object.keys(peers).forEach(userId => {
                if (!data.users.includes(userId)) {
                    console.log(`Removing ${userId} from peers list`);
                    delete peers[userId];
                }
            });
        });


        socket.on("user-speaking", ({ userId, isSpeaking }) => {
            console.log(`User ${userId} is speaking: ${isSpeaking}`);
            const userElement = document.getElementById(`user-${userId}`);
            if (userElement) {
                userElement.style.color = isSpeaking ? "green" : "black";
            }
        });

        socket.on("webrtc-signal", ({ signal, from }) => {
            if (!peers[from]) {
                createPeer(from, false);
            }

            if (peers[from].destroyed) {
                console.warn(`Peer connection with ${from} is destroyed. Ignoring signal.`);
                return;
            }

            try {
                console.log(`Receiving signal from ${from}:`, signal);
                
                // Ø¨Ø±Ø±Ø³ÛŒ ÙˆØ¶Ø¹ÛŒØª Ù‚Ø¨Ù„ Ø§Ø² `setRemoteDescription`
                if (signal.type === "answer" && peers[from].signalingState !== "have-local-offer") {
                    console.warn(`Ignoring answer from ${from} because the signaling state is ${peers[from].signalingState}`);
                    return;
                }

                setTimeout(() => {
                    peers[from].signal(signal);
                }, 200);
            } catch (err) {
                console.error(`WebRTC signal error from ${from}:`, err);
            }
        });

        function toggleMute() {
            if (stream) {
                isMuted = !isMuted;
                stream.getAudioTracks().forEach(track => {
                    track.enabled = !isMuted;
                });
                console.log(isMuted ? "Microphone muted" : "ðŸŽ¤ Microphone unmuted");
            } else {
                alert("No active microphone stream.");
            }
        }

        window.addEventListener("beforeunload", () => {
            socket.emit("leave-channel");
        });
    </script>
</body>
</html>